use std::{fs, path::Path, sync::Arc};
use toml::Value;
use walkdir::WalkDir;
use std::path::PathBuf;
use std::io::Write;
use swc_ecma_ast::{ModuleItem, Module, ImportSpecifier};
use swc_ecma_visit::Visit;
// use swc_common::{errors::Handler, FileName, sync::Lrc, SourceMap};
use swc_common::{
    self,
    errors::{ColorConfig, Handler, EmitterWriter},
    FileName, sync::Lrc, SourceMap
};
use swc_ecma_parser::{lexer::Lexer, Parser, StringInput, Syntax};
use swc::{config::Options, Compiler};
use std::fmt;

fn main() -> Result<(), Box<dyn std::error::Error>>{
    let content: String = fs::read_to_string("Config.toml")?;
    println!("配置路径 {}", content);

    let parsed_content: Value = content.parse()?;
    println!("配置路径 {}", parsed_content);

    let project_path_str = &parsed_content["frontend"]["project_path"].as_str().ok_or("Expected a string for project_path")?;
    println!("配置路径 {}", project_path_str);


    // 创建或清空 plugin.js 文件
    let output_file = "/Users/lilu/Code/2023/Rust/LearningRust/hello-world/plugin.js";
    let mut output = std::fs::File::create(output_file)?;

    let project_path = PathBuf::from(project_path_str);

    for entry in WalkDir::new( project_path).into_iter().filter_map(|e| e.ok()) {
        println!("{}", entry.path().display());

        // let file_path = entry.path();
        // println!("{:#?}", file_path);

        // if entry.path().extension().map_or(false, |ext| ext == "js" || ext == "vue") {
            // 处理.js和.vue文件
            let file_path = "/Users/lilu/Code/2023/Rust/LearningRust/hello-world/src/components/ThreeDemo.js";
            // let file_content = fs::read_to_string(file_path)?;

            // println!("{:#?}", file_content);
            // 解析 JavaScript 文件
            let cm: Lrc<SourceMap> = Default::default();
            let handler = Handler::with_emitter(
                true,
                false,
                Box::new(EmitterWriter::new(
                    Box::new(std::io::stderr()),
                    None,
                    false,
                    false,
                )),
            );            
            let fm = cm.new_source_file(FileName::Real(file_path.into()), std::fs::read_to_string(file_path).unwrap());
            let lexer = Lexer::new(Syntax::Es(Default::default()), Default::default(), StringInput::from(&*fm), None);
            let mut parser = Parser::new_from(lexer);
        
            let script = parser.parse_module().map_err(|err| {
                err.into_diagnostic(&handler).emit();
            }).expect("failed to parse script");
        
            // // Use the parsed `Script` object for further processing
            println!("{:#?}", script);
            let module_str = format!("{}", script);            
            writeln!(output_file, module_str);
            // 提取导入语句
            // let mut extractor = ImportExtractor::new(&mut output);
            // extractor.visit_script(&script);
        // }
    }

    // 写入结束标记
    // writeln!(output, "// This file is automatically generated by ThreeJS Import Extractor")?;

    Ok(())
}

struct ImportExtractor<'a> {
    output: &'a mut std::fs::File,
}

impl<'a> ImportExtractor<'a> {
    fn new(output: &'a mut std::fs::File) -> Self {
        ImportExtractor { output }
    }
}

impl Visit for ImportExtractor<'_> {
    fn visit_import_specifier(&mut self, specifier: &ImportSpecifier) {
        // if let Some(local) = &specifier.local {
        //     if let Some(imported) = &specifier.imported {
        //         // 如果导入的是 'three' 库
        //         if imported.sym == "three" {
        //             // 将导入语句写入 plugin.js
        //             let import_str = format!("import {{ {} }} from 'three';\n", local.name);
        //             self.output.write_all(import_str.as_bytes())?;
        //         }
        //     }
        // }
    }
}

impl fmt::Display for Module {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let body_str = self.body.iter()
            .map(|item| format!("{}", item))
            .collect::<Vec<_>>()
            .join("\n");
        write!(f, "{}", body_str)
    }
}
